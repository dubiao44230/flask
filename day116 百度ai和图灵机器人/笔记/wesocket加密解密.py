# 加密：
import struct

msg_bytes = "先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。" .encode("utf8")
token = b"\x81"
length = len(msg_bytes)

if length < 126:
    token += struct.pack("B", length)
elif length == 126:
    token += struct.pack("!BH", 126, length)
else:
    token += struct.pack("!BQ", 127, length)

msg = token + msg_bytes

print(msg)

# 解密：
b_str = b'\x81\xfe\x01G\xa0`~dE\xe5\xf6\x81\x18\xfd\x9b\xec;\x84\xc6\xfeF\xfc\xd4\x81-\xea\x96\xe4,\x84\xc6\xc9I\xe1\xed\x81\x14\xc9\x98\xca"\x8f\xc2\xe8D\xdb\xf4\x81\x04\xc9\x9a\xdc+\x84\xc6\xedE\xe8\xf8\x8b\x1c\xec\x99\xff*\x85\xc9\xfaG\xf6\xcc\x81\x1c\xea\x91\xd8,\x86\xd3\xc0H\xcf\xe4\x81-\xd1\x98\xe4\x05\x85\xd3\xfcD\xda\xdf\x80\x19\xeb\x99\xc3+\x84\xc7\xfbC\xe0\xfc\x83$\xd6\x9a\xda-\x85\xf3\xcfD\xd9\xf5\x8c\'\xc3\x9a\xdc-\x86\xf9\xecD\xda\xf0\x81&\xe5\x91\xd8,\x85\xc1\xc4E\xdf\xe9\x80\x19\xeb\x9b\xc7\x0b\x85\xc1\xfcH\xda\xd5\x80\x1a\xee\x9b\xc06\x88\xfe\xe1O\xdc\xf2\x83;\xf6\x96\xdb\x1d\x85\xfb\xecE\xd8\xe3\x80\x19\xeb\x98\xca*\x89\xff\xe3O\xdc\xf2\x82\x0c\xd2\x98\xee\x05\x84\xc7\xefD\xda\xf0\x8d9\xfb\x9a\xdc+\x84\xc7\xfbC\xe0\xfc\x8c\x0f\xfa\x9b\xca<\x85\xc2\xe4E\xdc\xde\x81<\xc3\x9b\xf4\x0c\x8f\xc2\xe8D\xdb\xdb\x81%\xe9\x9b\xe1(\x85\xc6\xf9I\xe1\xe9\x81\x1e\xd7\x91\xd8,\x86\xff\xc6E\xdc\xe6\x81\x1f\xf7\x9b\xc7\x0b\x84\xc7\xefF\xd0\xea\x8b\x1c\xec\x9a\xdc-\x85\xd0\xf8E\xc6\xfa\x8c\'\xca\x96\xeb\x12\x88\xe8\xe0O\xdc\xf2\x81\x1c\xf5\x9b\xf2\x1b\x85\xda\xd5D\xd9\xf7\x8b\x1c\xec\x9a\xdf\x05\x85\xdf\xfaE\xdf\xde\x8c\x10\xef\x9a\xdd+\x88\xc9\xcbD\xd9\xe1'
c_str = b'\x81\xfe\x02d\xbe@<\x07'
# 123 \x81
# [\x81,\x83,\xc8,\xbd,\xa6,\x9c,\xf9,\x8f,\x95]
# 1000011
# 0111111
# 0000011
# --------
# 1111110
# 0111111 127
# 0111110 126


data_lenth = b_str[1] & 127
# print(data_lenth)

# data_lenth == 127 之后的多少位为数据长度3-10字节代表数据长度 11-14为mask_key
if data_lenth == 127:
    extend_payload_len = b_str[2:10]
    mask = b_str[10:14]
    data = b_str[14:]

# data_lenth == 126 之后的多少位为数据长度3-4字节代表数据长度 65535 5-8为mask_key
if data_lenth == 126:
    extend_payload_len = b_str[2:4]
    mask = b_str[4:8]
    data = b_str[8:]

# data_lenth <= 125 当前的 data_lenth 就是数据的长度 125      3-6为mask_key
if data_lenth <= 125:
    extend_payload_len = b_str[1]
    mask = b_str[2:6]
    data = b_str[6:]

str_byte = bytearray()

for i in range(len(data)):
    byte = data[i] ^ mask[i % 4]  # 0123
    str_byte.append(byte)

print(str_byte.decode("utf8"))  #
